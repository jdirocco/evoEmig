pre {
	"Running ETL\n".println();
	
	// GLOBAL VARIABLES
	
	var DEBUG_MODE = false;
	
	// map <reference, referenced class attribute>
	// a cache to don't ask the user the same question over and over again,
	// used for replacing attributes that became references with
	// an attribute of the referenced class.
	var referenceReplacers = Map{};
	
	// map <attribute, replacer attribute>
	// as above, but for replacing attributes that were deleted with
	// an added attribute.
	var deletedAttributeReplacers = Map{};
	
	// map <reference, TemplateInvocation replacer template>
	// as above, but for replacing referred templates in template invocations
	// when they became invalid since the reference changed type.
	var templateReplacers = Map{};
}

post {
	"\nRunning Successful".println();
}

operation Any debug() : Any {
  if (DEBUG_MODE) {
    return self.println();
  }
}

// Custom equivalent function:
// is recursive and returns the element itself if there is no matching rule for it.
operation Any convert() {
  
  var equivalent;
  
  if (self.isKindOf(Collection)) {
    // collection -> recursion
    'Converting Collection '.concat(self.toString()).debug();
    equivalent = self->collect( element | element.convert() );
    'Converted: Collection '.concat(equivalent.toString()).debug();
  } else {
    // single element
    equivalent = self.equivalent();
    if (equivalent.isUndefined()) {
      // no matching rule(s)
      equivalent = self;
    }
  }

  return equivalent;
}
/////////////////////MIGRATION PART /////////////////////////////////// 

operation is_splitAttributeBNR2 (propCallExpOld : mtl!PropertyCallExp) : Boolean {
if(Pattern!splitAttributeBNR2.isUndefined())
	'cacchioNo'.println();
	else Pattern!splitAttributeBNR2ChangedClassBNR2.updatedElement.println(); 
return ( Pattern!splitAttributeBNR2.isUndefined()) and
	Pattern!splitAttributeBNR2ChangedClassBNR2.applicationElement = propCallExpOld.source.eType  and  
 1 = 1 and 1 = 1 and Pattern!splitAttributeBNR2DelAttribute.applicationElement = propCallExpOld.source.referredProperty 
;
}
rule splitAttributeBNR2
	transform propCallExpOld : mtl!PropertyCallExp
	to propCallExpNew : mtl!PropCallExp {
	guard: is_splitAttributeBNR2(propCallExpOld)
				'ci sono'.println();
				ordered <- propCallExpOld.ordered.convert();	

				var temp = System.user.choose(Choice, Sequence{Pattern!splitAttributeBNR2a1.convert(), Pattern!splitAttributeBNR2a2.convert()});

				eType <- temp.eType.convert();	
				source <- temp.eContainingClass.convert();	
				referredProprerty <- invalid.invalid.convert();	
				unique <- propCallExpOld.unique.convert();	
				lowerBound <- propCallExpOld.lowerBound.convert();	
				upperBound <- propCallExpOld.upperBound.convert();	
				startPosition <- propCallExpOld.startPosition.convert();	
				endPosition <- propCallExpOld.endPosition.convert();	
				propertyStartPosition <- propCallExpOld.propertyStartPosition.convert();	
				propertyEndPosition <- propCallExpOld.propertyEndPosition.convert();	
				markedPre <- propCallExpOld.markedPre.convert();	
	}	

operation is_extractInlineMetaClassBNR1 (propCallExpOld : mtl!PropertyCallExp) : Boolean {
return Pattern!extractInlineMetaClassBNR1.isUndefined() and
	Pattern!extractInlineMetaClassBNR1ChangedClassBNR1.applicationElement = propCallExpOld.source.eType  and  
 Pattern!extractInlineMetaClassBNR1DeleteAttributeBNR1.applicationElement = propCallExpOld.source.referredProperty 
and 1 = 1 and	1 = 1 and 1 = 1  and Pattern!extractInlineMetaClassBNR1addedClassBNR1 = Pattern!extractInlineMetaClassBNR1addReferenceBNR1.eType;
}
rule extractInlineMetaClassBNR1
	transform propCallExpOld : mtl!PropertyCallExp
	to propCallExpNew : mtl!PropCallExp {
	guard: is_extractInlineMetaClassBNR1(propCallExpOld)
		
				name <- propCallExpOld.name.convert();	

				var tempBNR1 = System.user.choose(Choice, Sequence{Pattern!extractInlineMetaClassBNR1addedAttribute1BNR1.convert(), Pattern!extractInlineMetaClassBNR1addedAttribute2BNR1.convert()});

				eType <- tempBNR1.eType.convert();	
				source <- tempBNR1.eContainingClass.convert();	
				referredProperty <- invalid.invalid.convert();	
				ordered <- propCallExpOld.ordered.convert();	
				unique <- propCallExpOld.unique.convert();	
				lowerBound <- propCallExpOld.lowerBound.convert();	
				upperBound <- propCallExpOld.upperBound.convert();	
				startPosition <- propCallExpOld.startPosition.convert();	
				endPosition <- propCallExpOld.endPosition.convert();	
				propertyStartPosition <- propCallExpOld.propertyStartPosition.convert();	
				propertyEndPosition <- propCallExpOld.propertyEndPosition.convert();	
				markedPre <- propCallExpOld.markedPre.convert();	
	}	

operation is_changeReferenceTypeBNR3 (templateInvocationOld : mtl!TemplateInvocation) : Boolean {
return 
	Pattern!changeReferenceTypeBNR3.isUndefined() and Pattern!changeReferenceTypeBNR3ChangedClassBNR3.applicationElement = templateInvocationOld.source.eType  and  
 1 = 1 ;
}
rule changeReferenceTypeBNR3
	transform templateInvocationOld : mtl!TemplateInvocation
	to templateInvocationNew : mtl!TemplateInvocation {
	guard: is_changeReferenceTypeBNR3(templateInvocationOld)
		
				name <- templateInvocationOld.name.convert();	
	}	
///////////////////////////////////////////////////////////////////////
///////////////////// CONSERVATIVE COPY ///////////////////////////////
// Updates everything to the evolved metamodel without doing any other change.

rule Module
  transform s : mtl!Module
  to t : mtl!Module {
  	'Transforming Module'.debug();
  	
	t.name = 'juri';
	t.nsURI = s.nsURI;
	t.nsPrefix = s.nsPrefix;
	t.deprecated = s.deprecated;
	t.startHeaderPosition = s.startHeaderPosition;
	t.endHeaderPosition = s.endHeaderPosition;
	t.eFactoryInstance = s.eFactoryInstance;
	t.documentation = s.documentation;
	
	t.eAnnotations = s.eAnnotations.convert();
	t.eClassifiers = s.eClassifiers.convert();
	t.eSubpackages = s.eSubpackages.convert();
	t.input = s.input.convert();
	t.`extends` = s.`extends`.convert();
	t.imports = s.imports.convert();
	t.ownedModuleElement = s.ownedModuleElement.convert();
	
	'Transformed: Module'.debug();
}
 
rule TypedModel
  transform s : mtl!TypedModel
  to t : mtl!TypedModel {
  	'Transforming TypedModel'.debug();

    t.takesTypesFrom = s.takesTypesFrom.convert(); // contains the main metamodel EPackage
    
    'Transformed: TypedModel'.debug();
  }

rule Template
  transform s : mtl!Template
  to t : mtl!Template {
  	'Transforming Template'.debug();
  
    t.name = s.name;
    t.ordered = s.ordered;
    t.unique = s.unique;
    t.lowerBound = s.lowerBound;
    t.upperBound = s.upperBound;
    t.startPosition = s.startPosition;
    t.endPosition = s.endPosition;
    t.visibility = s.visibility;
    t.deprecated = s.deprecated;
    t.main = s.main;
    t.eGenericType = s.eGenericType;
    t.init = s.init;
    t.documentation = s.documentation;
    t.`guard` = s.`guard`;
    t.`post` = s.`post`;
    
    t.eAnnotations = s.eAnnotations.convert();
    t.eType = s.eType.convert();
    t.body = s.body.convert();
    t.overrides = s.overrides.convert();
    t.parameter = s.parameter.convert(); // ocl::ecore::Variable
    
    'Transformed: Template'.debug();
  }
  
rule FileBlock
  transform s : mtl!FileBlock
  to t : mtl!FileBlock {
  	'Transforming FileBlock'.debug();
  
    t.name = s.name;
    t.ordered = s.ordered;
    t.unique = s.unique;
    t.lowerBound = s.lowerBound;
    t.upperBound = s.upperBound;
    t.startPosition = s.startPosition;
    t.endPosition = s.endPosition;
    t.openMode = s.openMode;
    t.eGenericType = s.eGenericType;
    t.init = s.init;
    t.uniqId = s.uniqId;
    t.charset = s.charset;
    
    t.eAnnotations = s.eAnnotations.convert();
    t.eType = s.eType.convert();
    t.body = s.body.convert();
    t.fileUrl = s.fileUrl.convert();
    
    'Transformed: FileBlock'.debug();
  }
  
rule ForBlock
  transform s : mtl!ForBlock
  to t : mtl!ForBlock {
  	'Transforming ForBlock'.debug();

    t.name = s.name;
    t.ordered = s.ordered;
    t.unique = s.unique;
    t.lowerBound = s.lowerBound;
    t.upperBound = s.upperBound;
    t.startPosition = s.startPosition;
    t.endPosition = s.endPosition;
    t.eGenericType = s.eGenericType;
    t.init = s.init;
    t.before = s.before;
    t.each = s.each;
    t.after = s.after;
    t.`guard` = s.`guard`;
    
    t.eAnnotations = s.eAnnotations.convert();
    t.eType = s.eType.convert();
    t.body = s.body.convert();
    t.loopVariable = s.loopVariable.convert();
    t.iterSet = s.iterSet.convert();
    
    'Transformed: ForBlock'.debug();
  }
  
rule IfBlock
  transform s : mtl!IfBlock
  to t : mtl!IfBlock {
    'Transforming IfBlock'.debug();
    
    t.name = s.name;
    t.ordered = s.ordered;
    t.unique = s.unique;
    t.lowerBound = s.lowerBound;
    t.upperBound = s.upperBound;
    //t.many = s.many; // Internal error: java.lang.NullPointerException
    //t.required = s.required; // Internal error: java.lang.NullPointerException
    t.startPosition = s.startPosition;
    t.endPosition = s.endPosition;
    
    t.body = s.body.convert();
    t.ifExpr = s.ifExpr.convert();
    t.`else` = s.`else`.convert();
    t.elseIf = s.elseIf.convert();
    
    'Transformed: IfBlock'.debug();
  }
  
rule Block
  transform s : mtl!Block
  to t : mtl!Block {
    'Transforming Block'.debug();
    
    t.name = s.name;
    t.ordered = s.ordered;
    t.unique = s.unique;
    t.lowerBound = s.lowerBound;
    t.upperBound = s.upperBound;
    //t.many = s.many; // Internal error: java.lang.NullPointerException
    //t.required = s.required; // Internal error: java.lang.NullPointerException
    t.startPosition = s.startPosition;
    t.endPosition = s.endPosition;
    
    t.body = s.body.convert();
  
    'Transformed: Block'.debug();
  }
  
rule TemplateInvocation
  transform s : mtl!TemplateInvocation
  to t : mtl!TemplateInvocation {
  guard : not is_changeReferenceTypeBNR3(s)
  	'Transforming TemplateInvocation'.debug();
  
    t.name = s.name;
    t.ordered = s.ordered;
    t.unique = s.unique;
    t.lowerBound = s.lowerBound;
    t.upperBound = s.upperBound;
    //t.many = s.many; // is just a Boolean but gives java.lang.NullPointerException
    //t.required = s.required; // as above
    t.startPosition = s.startPosition;
    t.endPosition = s.endPosition;
    t.super = s.super;
    
    t.argument = s.argument.convert();
    t.definition = s.definition.convert();
    t.eType = s.eType.convert();
    
    'Transformed: TemplateInvocation'.debug();
  }
  
// We need to use the right type here, which is under ocl::ecore,
// otherwise the rule won't match and won't be called.
// Don't use @greedy + mtl!StringLiteralExp since would lead to
// ArrayStoreException and cast errors when copying the transformed object in the parent.
rule StringLiteralExp
  transform s : mtl!ocl::ecore::StringLiteralExp
  to t : mtl!ocl::ecore::StringLiteralExp {   
  	'Transforming StringLiteralExp'.debug();
  
    t.startPosition = s.startPosition;
    t.endPosition = s.endPosition;
    t.stringSymbol = s.stringSymbol;
    
    t.eType = s.eType.convert();
    
    'Transformed: StringLiteralExp'.debug();
  }
  
rule PropertyCallExp
  transform s : mtl!ocl::ecore::PropertyCallExp
  to t : mtl!ocl::ecore::PropertyCallExp {
  guard : not is_extractInlineMetaClassBNR1(s) and not is_splitAttributeBNR2(s)
    'Transforming PropertyCallExp'.debug();
    
    t.name = s.name;
    t.ordered = s.ordered;
    t.unique = s.unique;
    t.lowerBound = s.lowerBound;
    t.upperBound = s.upperBound;
    //t.many = s.many; // is just a Boolean but gives java.lang.NullPointerException
    //t.required = s.required; // as above
    t.startPosition = s.startPosition;
    t.endPosition = s.endPosition;
    t.propertyStartPosition = s.propertyStartPosition;
    t.propertyEndPosition = s.propertyEndPosition;
    t.markedPre = s.markedPre;
    
    t.eType = s.eType.convert();
    t.source = s.source.convert();
    t.referredProperty = s.referredProperty.convertFromPropertyCallExp(s);
    
    'Transformed: PropertyCallExp'.debug();
  }
  
rule OperationCallExp
  transform s : mtl!ocl::ecore::OperationCallExp
  to t : mtl!ocl::ecore::OperationCallExp {
  	'Transforming OperationCallExp'.debug();
  
    t.startPosition = s.startPosition;
    t.endPosition = s.endPosition;
    t.propertyStartPosition = s.propertyStartPosition;
    t.markedPre = s.markedPre;
    t.operationCode = s.operationCode;
    t.propertyEndPosition = s.propertyEndPosition;
    
    t.source = s.source.convert();
    t.argument = s.argument.convert();
    t.eType = s.eType.convert();
    t.referredOperation = s.referredOperation.convert();
    
    'Transformed: OperationCallExp'.debug();
  }
  
rule TypeExp
  transform s : mtl!ocl::ecore::TypeExp
  to t : mtl!ocl::ecore::TypeExp {
    'Transforming TypeExp'.debug();
    
    t.name = s.name;
    t.ordered = s.ordered;
    t.unique = s.unique;
    t.lowerBound = s.lowerBound;
    t.upperBound = s.upperBound;
    //t.many = s.many; // is just a Boolean but gives java.lang.NullPointerException
    //t.required = s.required; // as above
    t.startPosition = s.startPosition;
    t.endPosition = s.endPosition;
    
    t.eType = s.eType.convert();
    t.referredType = s.referredType.convert();
    
    'Transformed: TypeExp'.debug();
  }

rule VariableExp
  transform s : mtl!ocl::ecore::VariableExp
  to t : mtl!ocl::ecore::VariableExp {
    'Transforming VariableExp'.debug();
    
	t.name = s.name;
	t.ordered = s.ordered;
	t.unique = s.unique;
	t.lowerBound = s.lowerBound;
	t.upperBound = s.upperBound;
	//t.many = s.many; // Internal error: java.lang.NullPointerException
	//t.required = s.required; // as above
	t.startPosition = s.startPosition;
	t.endPosition = s.endPosition;
	
	t.eType = s.eType.convert();
	t.referredVariable = s.referredVariable.convert();
	
	'Transformed: VariableExp'.debug();
  }

rule Variable
  transform s : mtl!ocl::ecore::Variable
  to t : mtl!ocl::ecore::Variable {
    'Transforming Variable'.debug();
    
    t.name = s.name;
    t.ordered = s.ordered;
    t.unique = s.unique;
    t.lowerBound = s.lowerBound;
    t.upperBound = s.upperBound;
    //t.many = s.many; // Internal error: java.lang.NullPointerException
    //t.required = s.required; // Internal error: java.lang.NullPointerException
    t.startPosition = s.startPosition;
    t.endPosition = s.endPosition;
    t.typeStartPosition = s.typeStartPosition;
    t.typeEndPosition = s.typeEndPosition;
    
    t.eType = s.eType.convert();
  
    'Transformed: Variable'.debug();
  }
  
rule SetType
  transform s : mtl!ocl::ecore::SetType
  to t : mtl!ocl::ecore::SetType {
    'Transforming SetType'.debug();

    t.name = s.name;
    t.instanceClassName = s.instanceClassName;
    //t.instanceClass = s.instanceClass; // Internal error: java.lang.NullPointerException
    //t.defaultValue = s.defaultValue; // Internal error: java.lang.NullPointerException
    t.instanceTypeName = s.instanceTypeName;
    t.serializable = s.serializable;
    t.startPosition = s.startPosition;
    t.endPosition = s.endPosition;
    t.typeStartPosition = s.typeStartPosition;
    t.typeEndPosition = s.typeEndPosition;
    //t.kind = s.kind; // Internal error: java.lang.NullPointerException
    
    t.elementType = s.elementType.convert();
    
    'Transformed: SetType'.debug();
  }

rule OrderedSetType
  transform s : mtl!ocl::ecore::OrderedSetType
  to t : mtl!ocl::ecore::OrderedSetType {
    'Transforming OrderedSetType'.debug();
    
    t.name = s.name;
    t.instanceClassName = s.instanceClassName;
    //t.instanceClass = s.instanceClass; // Internal error: java.lang.NullPointerException
    //t.defaultValue = s.defaultValue; // Internal error: java.lang.NullPointerException
    t.instanceTypeName = s.instanceTypeName;
    t.serializable = s.serializable;
    t.startPosition = s.startPosition;
    t.endPosition = s.endPosition;
    t.typeStartPosition = s.typeStartPosition;
    t.typeEndPosition = s.typeEndPosition;
    //t.kind = s.kind; // Internal error: java.lang.NullPointerException
    
    t.elementType = s.elementType.convert();
  
    'Transformed: OrderedSetType'.debug();
  }
  
rule CollectionLiteralExp
  transform s : mtl!ocl::ecore::CollectionLiteralExp
  to t : mtl!ocl::ecore::CollectionLiteralExp {
    'Transforming CollectionLiteralExp'.debug();
    
    t.name = s.name;
    t.ordered = s.ordered;
    t.unique = s.unique;
    t.lowerBound = s.lowerBound;
    t.upperBound = s.upperBound;
    //t.many = s.many; // Internal error: java.lang.NullPointerException
    //t.required = s.required; // Internal error: java.lang.NullPointerException
    t.startPosition = s.startPosition;
    t.endPosition = s.endPosition;
    t.kind = s.kind;
    //t.simpleRange = s.simpleRange; // Internal error: java.lang.NullPointerException
    
    t.eType = s.eType.convert();
    t.eAnnotations = s.eAnnotations.convert();
    t.part = s.part.convert(); // TODO: CollectionItem
    
    'Transformed: CollectionLiteralExp'.debug();
  }
  
rule CollectionItem
  transform s : mtl!ocl::ecore::CollectionItem
  to t : mtl!ocl::ecore::CollectionItem {
    'Transforming CollectionItem'.debug();
    
    t.name = s.name;
    t.ordered = s.ordered;
    t.unique = s.unique;
    t.lowerBound = s.lowerBound;
    t.upperBound = s.upperBound;
    //t.many = s.many; // Internal error: java.lang.NullPointerException
    //t.required = s.required; // Internal error: java.lang.NullPointerException
    
    t.eType = s.eType.convert();
    t.item = s.item.convert();
    
    'Transformed: CollectionItem'.debug();
  }
  
// Metamodel instances are converted without transformation rules since their counterpart
// already exists in the evoMetamodel, it just need to be retrieved.

operation Metamodel!ecore::EPackage convert() : evoMetamodel!ecore::EPackage {
  'Converting EPackage '.concat(self.name).debug();

  // get the relative package from the evolved metamodel
  var evoPackage = evoMetamodel!ecore::EPackage.allInstances()->selectOne(package | package.name == self.name);  

  'Converted: EPackage '.concat(self.name).debug();

  return evoPackage;
}

operation Metamodel!ecore::EClass convert() : evoMetamodel!ecore::EClass {
  'Converting EClass '.concat(self.name).debug();

  // get the relative class from the evolved metamodel
  var evoClass = evoMetamodel!ecore::EClass.allInstances()->selectOne(metaclass | metaclass.name == self.name);  

  'Converted: EClass '.concat(self.name).debug();

  return evoClass;
}

// EAttribute is converted by using the PropertyCallExp since otherwise there is no reliable way to get the parent class
// (comparison with allInstances() returns always false), while with it the source.eType can be used.
operation Metamodel!ecore::EAttribute convertFromPropertyCallExp(s : mtl!ocl::ecore::PropertyCallExp) : evoMetamodel!ecore::EAttribute {
  // (self is the PropertyCallExp referredProperty)
  
  'Converting EAttribute '.concat(self.name).debug();
  
  // get EAttribute evolved parent EClass
  var parentClass = s.source.eType;
  var evoParentClass = parentClass.convert();
  
  // get the evolved attribute from the evolved class.
  // Note: the attribute could be in a super class, so we use eAllAttributes to get also super class attributes.
  var evoAttribute = evoParentClass.eAllAttributes->selectOne(evoAttribute | evoAttribute.name == self.name);
  
  'Converted: EAttribute '.concat(self.name).debug();

  return evoAttribute;
}

// EReference is converted by using the PropertyCallExp since otherwise there is no reliable way to get the parent class
// (comparison with allInstances() returns always false), while with it the source.eType can be used.
operation Metamodel!ecore::EReference convertFromPropertyCallExp(s : mtl!ocl::ecore::PropertyCallExp) : evoMetamodel!ecore::EReference {
  // (self is the PropertyCallExp referredProperty)
  
  'Converting EReference '.concat(self.name).debug();
  
  // get EReference evolved parent EClass
  var parentClass = s.source.eType;
  var evoParentClass = parentClass.convert();
  
  // get the evolved reference from the evolved class.
  // Note: the reference could be in a super class, so we use eAllReferences to get also super class references.
  var evoReference = evoParentClass.eAllReferences->selectOne(evoReference | evoReference.name == self.name);
  
  'Converted: EReference '.concat(self.name).debug();
  
  return evoReference;
}

operation Metamodel!ecore::EEnum convert() : evoMetamodel!ecore::EEnum {
  'Converting EEnum '.concat(self.name).debug();

  // get the relative enum from the evolved metamodel
  var evoEnum = evoMetamodel!ecore::EEnum.allInstances()->selectOne(enum | enum.name == self.name);
  
  'Converted: EEnum '.concat(self.name).debug();
  
  return evoEnum;
}
